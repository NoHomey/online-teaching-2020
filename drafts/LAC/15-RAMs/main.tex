\documentclass[14pt]{extarticle}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usepackage{float}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,bulgarian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathabx}
\usepackage{relsize}
\usepackage{euler}
\usepackage[a4paper, portrait, margin=1.8cm]{geometry}

\title{RAM машини}
\author{Иво Стратев}

\begin{document}
\maketitle
\section*{Увод}
Няма да дефинираме формално понятието RAM машина, нито ще въвеждаме формализъм за работа с тях.
Защото единствено ще пишем програми за такива машини. Реално всяка RAM машина донякъде е теоретичен аналог на съвременните компютри.

\subsection*{Инструкции}
В програмите, които ще пишем ще позволим само четири вида инструкции/команди, които по идея са аналог на базови инструкци част от, който да е асемблер.
Инструкциите са следните:
\begin{itemize}
    \item \(Z(n)\) - нулирай стойността на клетка \(n\) от паметта и изпълни следващата инструкция.
    \item \(S(n)\) - увеличи стойността на клетка \(n\) от паметта с единица и изпълни следващата инструкция.
    \item \(T(n, k)\) - копирай стойността на клетка \(n\) в клетка \(k\) от паметта и изпълни следващата инструкция.
    \item \(J(n, k, l)\) - ако стойностите на клетки \(n\) и \(k\) съвпадат премини към изпълнението на \(l\)-тата инструкция на програмата в противен случай изпълни следващата инструкция.
\end{itemize}
RAM е съкращение за Random access memory, което се превежда на български като памет с произволен достъп. Тоест директно можем да четем и променяме стойността на всяка клетка от паметта. Докато при машините на Тюринг достъпа до паметта е последователен - имаме глава, която се движи наляво и надясно.
Въпреки произволният достъп до паметта не получаваме по-мощен изчислителен модел. Действието на всяка RAM машина може да бъде симулирано от машина на Тюринг и обратното.
\subsection*{Програми}
С всяка RAM машина чрез нейната програма бива изчислявана някоя частична функция над естествени числа.
Приемаме, че в началото на изпълнение на програмата на една RAM машина в клетки от \(1\) до \(k\) са записани входните стойности,
а в клетка \(0\) е резултатната стойност ако машината успее да завърши достигайки до празен ред от програмата.

\subsubsection*{Безопасно вадене на единица}
Искаме да напишем програма за машина, която да изчисли фунцкията \(n \mapsto n \dotdiv 1\), където
\begin{align*}
    n \dotdiv 1 = \begin{cases}
    0 &,\; n = 0 \\
    n - 1 &,\; n > 0
    \end{cases}
\end{align*}
Стойността на входа ще бъде в клетка \(1\), изхода трябва да е в клетка \(0\), за това ще ползваме клетка \(2\) като помощтен брояч.
Идеята е следната пръво ще запишем \(0\) в клетка \(0\) след това ще направим проверка дали стойността в клетка \(1\) е нула.
Ако не е, първо ще увеличаваме стойността в клетка \(2\) и ще я сравняваме с тази в \(1\), ако не са равни, то тя е по-малка и ще увеличаваме стойността в клетка \(0\) и след това ще се връщаме на проверката. Така реално ще имаме един цикъл, при който стойността в клетка \(2\) винаги е с единица по-голяма от тази в клетка \(0\).
\begin{align*}
    & \quad 1 \; : \; Z(0) \\
    & \quad 2 \; : \; J(0, 1, \_) \\
    & \quad 3 \; : \; Z(2) \\
    & \quad 4 \; : \; S(2) \\
    & \quad 5 \; : \; J(1, 2, \_) \\
    & \quad 6 \; : \; S(0) \\
    & \quad 7 \; : \; J(0, 0, \_)
\end{align*}
Подчертавките са защото докато пишем програмата е по-лесно да съобразяваме алгоритъма, а след това редовете, на които трябва да се направят скоковете, така че алгоритъма да е коректен. След като имаме всички инструкции лесно се съобразява как да попълним празните места.
\begin{align*}
    & \quad 1 \; : \; Z(0) \\
    & \quad 2 \; : \; J(0, 1, 8) \\
    & \quad 3 \; : \; Z(2) \\
    & \quad 4 \; : \; S(2) \\
    & \quad 5 \; : \; J(1, 2, 8) \\
    & \quad 6 \; : \; S(0) \\
    & \quad 7 \; : \; J(0, 0, 4)
\end{align*}
Сега понеже командите не са особено лесни за четене ще въведем означения, които да са по-удобни.
\begin{itemize}
    \item  Вместо \(Z(n)\) ще пишем \(X_n := 0\).
    \item Вместо \(S(n)\) ще пишем \(X_n := X_n + 1\).
    \item Вместо \(T(n, k)\) ще пишем \(X_k := X_n\).
    \item Вместо \(J(n, k, l)\) ще пишем \(\mathsf{if} \; X_n = X_k \; \mathsf{then} \; \mathtt{goto} \; l\).
\end{itemize}
Така горната програма става:
\begin{align*}
    & \quad 1 \; : \; X_0 := 0 \\
    & \quad 2 \; : \; \mathsf{if} \; X_0 = X_1 \; \mathsf{then} \; \mathtt{goto} \; 8 \\
    & \quad 3 \; : \; X_2 := 0 \\
    & \quad 4 \; : \; X_2 := X_2 + 1 \\
    & \quad 5 \; : \; \mathsf{if} \;  X_1 = X_2 \; \mathsf{then} \; \mathtt{goto} \; 8 \\
    & \quad 6 \; : \; X_0 := X_0 + 1\\
    & \quad 7 \; : \; \mathsf{if} \; X_0 = X_0 \; \mathsf{then} \; \mathtt{goto} \; 4
\end{align*}
\subsubsection*{Отсечена разлика}
Искаме да напишем програма за RAM машина, която да изчислява функцията \(n, k \mapsto n \dotdiv k\),
където
\begin{align*}
    n \dotdiv k = \begin{cases}
    0 &,\; n < k \\
    n - k &,\; n \geq k
    \end{cases}
\end{align*}
В кода на програмата ще използваме идеята на кода, от предната програма,
защото забележете, че например \(2 \dotdiv 4 = 0\), което е същото като
\[(((2 \dotdiv 1) \dotdiv 1) \dotdiv 1) \dotdiv 1\]
Тоест можем един вид да итерираме безопасното вадене на единица.
Съобразяваме, че в \(X_0\) трябва да е резултата, а входните променливи са \(X_1\) и \(X_2\).
Следователно можем да ползваме \(X_3\) като брояч за итерациите, а \(X_4\), \(X_5\) и \(X_6\) за ваденето на единица.
Като на всяка итерация \(X_5\) ще има стойност \(X_1 \dotdiv X_3\). Така когато \(X_3 = X_2\) е истина, то \(X_5 = X_1 \dotdiv X_2\) ще е истина и значи накрая ще трябва да направим присвояването \(X_0 := X_5\). 
\begin{align*}
    & \quad 1 \; : \; X_3 := 0 \\
    & \quad 2 \; : \; X_5 := X_1 \\
    & \quad 3 \; : \; \mathsf{if} \; X_3 = X_2 \; \mathsf{then} \; \mathtt{goto} \; 14 \\
    & \quad 1 + 3 \; : \; X_{0 + 4} := 0 \\
    & \quad 2 + 3 \; : \; \mathsf{if} \; X_{0 + 4} = X_{1 + 4} \; \mathsf{then} \; \mathtt{goto} \; 8 + 3 \\
    & \quad 3 + 3 \; : \; X_{2 + 4} := 0 \\
    & \quad 4 + 3 \; : \; X_{2 + 4} := X_{2 + 4} + 1 \\
    & \quad 5 + 3 \; : \; \mathsf{if} \;  X_{1 + 4} = X_{2 + 4} \; \mathsf{then} \; \mathtt{goto} \; 8 + 3 \\
    & \quad 6 + 3 \; : \; X_{0 + 4} := X_{0 + 4} + 1\\
    & \quad 7 + 3 \; : \; \mathsf{if} \; X_{0 + 4} = X_{0 + 4} \; \mathsf{then} \; \mathtt{goto} \; 2 + 3 \\
    & \quad 11 \; : \; X_5 := X_4 \\
    & \quad 12 \; : \; X_3 := X_3 + 1 \\
    & \quad 13 \; : \; \mathsf{if} \; X_3 = X_3 \; \mathsf{then} \; \mathtt{goto} \; 3 \\
    & \quad 14 \; : \; X_0 := X_5
\end{align*}
Буквално "наляхме"\;кода на програмата за безопасно вадене на единица, като сме направили необходимите отмествания.
Бихме могли този код да го съкратим като \(X_4 := X_5 \dotdiv 1\) и тогава да получим по-лесна за четене и разбиране програма.
\begin{align*}
    & \quad 1 \; : \; X_3 := 0 \\
    & \quad 2 \; : \; X_5 := X_1 \\
    & \quad 3 \; : \; \mathsf{if} \; X_3 = X_2 \; \mathsf{then} \; \mathtt{goto} \; 8 \\
    & \quad 4 \; : \; X_4 := X_5 \dotdiv 1 \\
    & \quad 5 \; : \; X_5 := X_4 \\
    & \quad 6 \; : \; X_3 := X_3 + 1 \\
    & \quad 7 \; : \; \mathsf{if} \; X_3 = X_3 \; \mathsf{then} \; \mathtt{goto} \; 3 \\
    & \quad 8 \; : \; X_0 := X_5
\end{align*}
Тоест всеки път когато имаме програма за машина, която изчислява дадена функция можем директно да я използваме в следваща програма стига да съобразим, кои променливи е безопасно да ползваме.
\newpage
\subsubsection*{За домашно}
Напишете програми, които да изчисляват следните две функции
\begin{align*}
    g(x, y) = \begin{cases}
    1 &, \; x < y \\
    0 &,\; x \geq y
    \end{cases}
\end{align*}
и
\begin{align*}
    f(x, y) \simeq \begin{cases}
    \lnot! &, \; y = 0 \\
    x \;\mathbf{mod}\; y &,\; y > 0
    \end{cases}
\end{align*}
За целта използвайте следната рекурсивна програма
\begin{align*}
    F(X,Y) \; \mathsf{where} \\
    & F(X, Y) =  \mathsf{if} \; X \;\mathbf{<}\; Y \; \mathsf{then} \; X  \; \mathsf{else} \; F(X \dotdiv Y, Y)
\end{align*}
\end{document}
